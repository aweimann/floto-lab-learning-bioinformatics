---
title: "More Advanced R"
author: "Chris Ruis"
output: 
  html_document:
    theme: paper
    highlight: tango
    toc: true
    toc_float: true
    toc_collapsed: true
    number_sections: TRUE
---

In the first R tutorial, we covered quite a broad range of coding tools in R, including creating variables, using your own and existing functions, running loops and conditional statements and reading and writing files. In this tutorial, we're going to build on that and bring in a set of additional functions that should be useful for analysing your data. Feel free to look back at the previous tutorial if you can't remember how to do things.

# Data tables

Data tables are similar to data frames in that they look like excel spreadsheets. You have columns and rows in the same way as you would with a data frame and you can have different types of data (e.g. numbers, sample names) in different columns. I only recently learnt that data tables existed (thanks Santi!) so am still learning about what you can do with them. But I think its fair to say that they're a bit easier to use than data frames.

Whenever you want to use data tables, you'll need to load the data tables library, as they're not a standard feature of R. So before you use them for the first time, you'll need to install the "data.tables" package (have a look in the Introduction to R or How to use RStudio tutorials if you're not sure how to do this) and you'll then need to load the package each time you want to use it. As a quick aside, if you write a script that uses data tables, you'll need to have library(data.table) at the top of that script.

# Creating a data table

Ok, so how do we create a data table? Its essentially the same as creating a data frame, but using data.table instead of data.frame. We're going to create a data table of membrane potential measurements in two different ways. In the first example, we're going to write the data that's going into the data table by hand in R. There's a bit more data in this example than in the previous tutorials, so writing it out by hand is a bit more time consuming. Therefore, in the second example, we're going to read in an excel spreadsheet containing the membrane potential measurements and convert that into a data table. When you have your own data, you're likely to have it in excel or as a csv or text file and so its most likely that you'll want to use the second option most of the time. To read in an excel spreadsheet, you need to have a library called readxl. Check if you already have it installed in RStudio (see section 7 in the "How to use RStudio" tutorial if you're not sure how to do this) and install it if you don't.

You can find the excel spreadsheet containing the data in the GitHub folder.

```{r eval = FALSE}

library(data.table) # Remember you need to do this before you can use data tables, but you only need it once per script or per RStudio session
library(readxl)     # This is the library to read in excel files, you'll need to install it if you don't already have it
library(magrittr)

exampleDT <- data.table(Cell_type = rep(c("A", "B"), each = 5), 
                        Sample = paste0("Sample", 1:10) %>% rep(., 2), 
                        Measurement1 = c(1.2,1.4,2.5,2.7,1.6,2.4,2.2,1.9,1.4,1.5,2.1,2.4,2.7,2.6,3.1,1.9,2.8,2.7,2.3,2.2), 
                        Measurement2 = c(1.4,1.5,2.2,2.8,1.5,2.5,2.2,1.7,1.4,1.5,2.2,2.9,2.4,2.1,2.9,1.7,2.6,2.2,2.2,2.5)) #Creates a data table by hand

memPotDT <- data.table(read_excel("more_advanced_R_membrane_potential.xlsx")) #Imports our excel spreadsheet and converts it into a data table

```

By default, read_excel doesn't import the data as a data table, so we therefore need to put data.table around the import command to turn the data into a data table. Print the data tables to the screen so we can have a look at them. They should be the same. In this (made up) example, we've taken membrane potential measurements from two cell types, A and B. We've got 10 independent experiments using each cell type and we've measured the membrane potential twice in each experiment. Therefore in our data table, we've got 10 rows for each cell type and two measurements in each row. In our data table, column 1 is the cell type, column 2 is the experiment number within that cell type and columns 3 and 4 are the measurements.

Now we've imported our data, let's explore it!

# Sorting tables

Let's first look at the range of values we have for the membrane potential measurements. While all of the measurements are in the data table, it will be easier to look at the range of values we have if we sort the columns. You can sort data in a data table just as you can in excel. We need to pick the column(s) to sort the data on. The way we do that with a data table is putting the column name(s) inside square brackets. Let's sort the membrane potential table by measurement 1:

```{r eval = FALSE}

memPotDT[order(Measurement1)]

```

We put the square brackets after the name of our data table so R knows we want to do something with this object. Within the brackets, we tell R what we want to do and which column we want to use to do it. So here, we want to order the data table and we want to use the column called Measurement1 to do that. If you look at the output from this line of code, you should see that column Measurement1 starts with its smallest value (1.2) and ascends to its largest value (3.1). R has also changed the order of the other columns to keep the rows together. So we can see from this that the 6 smallest measurments in Measurement1 are from cell type A.

---

**Exercises**

1) Sort memPotDT by column Measurement2 - does it look like cell type A also has the smallest values here?

---

We've sorted the data table by Measurement1 in ascending order. We can also sort in descending order by putting a minus sign before the column name:

```{r eval = FALSE}

memPotDT[order(-Measurement1)]

```

You should see that the data table is sorted in descending order by the value in Measurement1. We can also sort on multiple columns. As an example, let's sort the data table on the Measurement1 values but keep cell types A and B apart:

```{r eval = FALSE}

memPotDT[order(Cell_type, Measurement1)]

```

If you look in column Cell_type, you can see that the ten cell type A rows have been kept together as have the ten cell type B rows. But we've sorted within cell type A so the Measurment1 values are in ascending order, and likewise within cell type B. The order in which we put the column names in this command matters. R will sort on the first column name first, and then on the second, then the third, etc. So memPotDT[order(Cell_type, Measurement1)] gives a different result to memPotDT[order(Measurement1,Cell_type)].

---

**Exercises**

2) Sort memPotDT by cell type and then by Measurement 2 in descending order

---

# Filtering tables

Filtering a table to keep only rows that match a particular criteria can be very useful. For example, you can select all of the genes with a significant p-value. As with sorting, we can filter our data table based on the values in multiple columns. We again filter by using square brackets:

```{r eval = FALSE}

memPotDT[Cell_type == "A"] # Filter memPotDT to keep only the rows with Cell_type A, remember the quotes around A as its a character value
memPotDT[Measurement1 > 2.5] # Filter memPotDT to keep only the rows whose Measurement1 is greater than 2.5
memPotDT[Measurement1 > 2.5 & Measurement2 > 2.5] # Filter memPotDT to keep only the rows whose Measurement1 and Measurement2 are greater than 2.5
memPotDT[Measurement1 > 2.5 | Measurement2 > 2.5] # Filter memPotDT to keep only the rows whose Measurement1 or Measurement2 is greater than 2.5

```

To filter based on a column, we put the column name in the square brackets followed by some criteria we want to match. In the first example, we filter on Cell_type and only keep rows if their Cell_type is A. The "==" checks if the left hand side and right hand side are the same. So here it checks if the value in column Cell_type is "A" and keeps it if and only if it is.

The second example filters based on column Measurement1 and keeps the row if its Measurement1 is greater than 2.5. We can also include multiple criteria and specify that all of these criteria or at least one of these criteria is met to keep a row. In R, if we want criteria 1 AND criteria 2 to be met, we use the "&" symbol. If we want criteria 1 OR criteria 2 to be met, we use the "|" symbol. So in example 3, we keep rows if they have Measurement1 AND measurement2 both greater than 2.5. While in example 4, we keep rows if they have Measurement1 OR Measurement2 greater than 2.5. We've just combined 2 criteria here, but you can use as many as you like as long as you can keep track of exactly what you're specifying! For example, try this:

```{r eval = FALSE}

memPotDT[Cell_type == "A" & ((Measurement1 > 2.5 & Measurement2 > 2.5) | (Measurement1 < 2.0 & Measurement2 < 2.0))]

```

This is a bit more complicated. R will return rows only if the overall outcome of the square brackets is true. The overall outcome of the square brackets is determined by each of the components within the square brackets.

We keep rows only if they're Cell_type A and the match the criteria in the (). We've actually got two criteria in the brackets, each containing two criteria. Both measurements need to be greater than 2.5 or less than 2.0. We can use these criteria to select data.

# Lists

# Merging tables

Single column and multiple column